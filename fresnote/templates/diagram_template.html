
  <!DOCTYPE html>
  <html lang="en">
    <html lang="en">
    <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, viewport-fit=cover"/>
    <meta name="description" content="A diagram holding groups that incrementally grow the diagram as groups are expanded."/> 
    <link rel="stylesheet" href="{{url_for('static', filename='gojssrc/style.css')}}"> 
    <!-- Copyright 1998-2021 by Northwoods Software Corporation. -->
    <title>Diagram</title>
    </head>

  <body>
  <script src="{{url_for('static', filename='gojssrc/go.js')}}"></script>
  <script src="{{url_for('static', filename='gojssrc/HyperlinkText.js')}}"></script>
  <div id="allSampleContent" class="p-4 w-full">
    <script id="code">
    function init() {

      // Since 2.2 you can also author concise templates with method chaining instead of GraphObject.make
      // For details, see https://gojs.net/latest/intro/buildingObjects.html
      const $ = go.GraphObject.make;  // for conciseness in defining templates

      myDiagram =
        $(go.Diagram, "myDiagramDiv",  // must name or refer to the DIV HTML element
          {
            // have mouse wheel events zoom in and out instead of scroll up and down
            "toolManager.mouseWheelBehavior": go.ToolManager.WheelZoom,
            // support double-click in background creating a new node
            "clickCreatingTool.archetypeNodeData": { text: "new node", img: "", caption: "", width: 5, height: 5 },
            "InitialLayoutCompleted": e => showIncremental("InitialLayout"),
            "ModelChanged": e => {
              if (e.isTransactionFinished) {
                // this records each Transaction as a JSON-format string
                showIncremental(myDiagram.model.toIncrementalJson(e));
              }
            },
            // enable undo & redo
            "undoManager.isEnabled": true,
            "toolManager.hoverDelay": 100,
            "toolManager.toolTipDuration": 50000
          });

      // when the document is modified, add a "*" to the title and enable the "Save" button
      myDiagram.addDiagramListener("Modified", e => {
        var button = document.getElementById("SaveButton");
        if (button) button.disabled = !myDiagram.isModified;
        var idx = document.title.indexOf("*");
        if (myDiagram.isModified) {
          if (idx < 0) document.title += "*";
        } else {
          if (idx >= 0) document.title = document.title.slice(0, idx);
        }
      });

      // define the Node template
      myDiagram.nodeTemplate =
        $(go.Node, "Auto",
          new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
          // define the node's outer shape, which will surround the TextBlock
          $(go.Shape, "RoundedRectangle",
            {
              parameter1: 20,  // the corner has a large radius
              fill: $(go.Brush, "Linear", { 0: "rgb(254, 201, 0)", 1: "rgb(254, 162, 0)" }),
              stroke: "black",
              portId: "",
              fromLinkable: true,
              fromLinkableSelfNode: true,
              fromLinkableDuplicates: true,
              toLinkable: true,
              toLinkableSelfNode: true,
              toLinkableDuplicates: true,
              cursor: "pointer"
            },
            new go.Binding("fill", "color")
            ),
          { // this tooltip shows the name and picture of the kitten
            toolTip:
              $("ToolTip",
                $(go.Panel, "Vertical",
                  // $(go.Picture, { margin: 3 },
                  //   new go.Binding("source", "src", s => "images/" + s + ".png")),
                  $(go.Picture, { margin: 3 },
                    new go.Binding("source", "img"), 
                    new go.Binding("width", "width"), 
                    new go.Binding("height", "height")),
                  $(go.TextBlock, { margin: 3 },
                    new go.Binding("text", "caption"))
                )
              )  // end Adornment
          },
          $(go.TextBlock,
            {
              font: "bold 11pt helvetica, bold arial, sans-serif",
              editable: true  // editing the text automatically updates the model data
            },
            new go.Binding("text", "text").makeTwoWay()),
          $("HyperlinkText",
                function(node) { return node.data.url; },
                function(node) { return ""; },
                { margin: 10 }
             )
        );

      // unlike the normal selection Adornment, this one includes a Button
      myDiagram.nodeTemplate.selectionAdornmentTemplate =
        $(go.Adornment, "Spot",
          $(go.Panel, "Auto",
            $(go.Shape, { fill: null, stroke: "blue", strokeWidth: 2 }),
            $(go.Placeholder)  // this represents the selected Node
          ),
          // the button to create a "next" node, at the top-right corner
          $("Button",
            {
              alignment: go.Spot.TopRight,
              click: addNodeAndLink  // this function is defined below
            },
            $(go.Shape, "PlusLine", { desiredSize: new go.Size(6, 6) })
          ), // end button
          $("Button",
            {
              alignment: go.Spot.BottomRight,
              click: showNodeNotes  // this function is defined below
            },
            $(go.TextBlock, "notes", { desiredSize: new go.Size(35, 15) })
          ) // end button
        ); // end Adornment

      // clicking the button inserts a new node to the right of the selected node,
      // and adds a link to that new node
      function addNodeAndLink(e, obj) {
        var adorn = obj.part;
        e.handled = true;
        var diagram = adorn.diagram;
        diagram.startTransaction("Add State");

        // get the node data for which the user clicked the button
        var fromNode = adorn.adornedPart;
        var fromData = fromNode.data;
        // create a new "State" data object, positioned off to the right of the adorned Node
        var toData = { text: "new" };
        var p = fromNode.location.copy();
        p.x += 200;
        toData.loc = go.Point.stringify(p);  // the "loc" property is a string, not a Point object
        // add the new node data to the model
        var model = diagram.model;
        model.addNodeData(toData);

        // create a link data from the old node data to the new node data
        var linkdata = {
          from: model.getKeyForNodeData(fromData),  // or just: fromData.id
          to: model.getKeyForNodeData(toData),
          text: "transition"
        };
        // and add the link data to the model
        model.addLinkData(linkdata);

        // select the new Node
        var newnode = diagram.findNodeForData(toData);
        diagram.select(newnode);

        diagram.commitTransaction("Add State");

        // if the new node is off-screen, scroll the diagram to show the new node
        diagram.scrollToRect(newnode.actualBounds);
      }

      // Shows node's nodes in console
      function showNodeNotes(e, obj) {
        console.log(obj.part.data.notes)
      }

      // replace the default Link template in the linkTemplateMap
      myDiagram.linkTemplate =
        $(go.Link,  // the whole link panel
          {
            curve: go.Link.Bezier, adjusting: go.Link.Stretch,
            reshapable: true, relinkableFrom: true, relinkableTo: true
          },
          new go.Binding("points").makeTwoWay(),
          new go.Binding("curviness", "curviness"),
          $(go.Shape,  // the link shape
            { strokeWidth: 1.5 }),
          $(go.Shape,  // the arrowhead
            { toArrow: "standard", stroke: null }),
          $(go.Panel, "Auto",
            $(go.Shape,  // the label background, which becomes transparent around the edges
              {
                fill: $(go.Brush, "Radial",
                  { 0: "rgb(240, 240, 240)", 0.3: "rgb(240, 240, 240)", 1: "rgba(240, 240, 240, 0)" }),
                stroke: null
              }),
            $(go.TextBlock, "transition",  // the label text
              {
                textAlign: "center",
                font: "10pt helvetica, arial, sans-serif",
                stroke: "black",
                margin: 4,
                editable: true  // editing the text automatically updates the model data
              },
              new go.Binding("text", "text").makeTwoWay())
          )
        );

      // Get json for filename
      var textArea = document.getElementById("mySavedModel");
      const request = new XMLHttpRequest();
      request.open('GET', "{{filename}}", true);
      request.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
      request.send(null);
      request.onload = function() {
              textArea.value = request.responseText;
              // read in the JSON-format data from the "mySavedModel" element
              load();
          };
    }

    // Show the diagram's model in JSON format
    function save() {
      document.getElementById("mySavedModel").value = myDiagram.model.toJson();
      myDiagram.isModified = false;
      showIncremental("");
    }
    function load() {
      var model = go.Model.fromJson(document.getElementById("mySavedModel").value);
      // establish GraphLinksModel functions:
      // node data id's are odd numbers
      model.makeUniqueKeyFunction = (model, data) => {
        var i = model.nodeDataArray.length * 2 + 1;
        while (model.findNodeDataForKey(i) !== null) i += 2;
        data.id = i;  // assume Model.nodeKeyProperty === "id"
        return i;
      };
      // link data id's are even numbers
      model.makeUniqueLinkKeyFunction = (model, data) => {
        var i = model.linkDataArray.length * 2 + 2;
        while (model.findLinkDataForKey(i) !== null) i += 2;
        data.id = i;  // assume GraphLinksModel.linkKeyProperty === "id"
        return i;
      };
      myDiagram.model = model;
      showIncremental("");
    }

    function showIncremental(str) {
      // show the last transaction as an incremental update in JSON-formatted text
      var element = document.getElementById("myTransaction");
      // don't show anything upon the initial layout
      if (element.value === "InitialLayout") str = "";
      element.value = str;
    }

      function store_diagram(notebook) {
          var textArea = document.getElementById("mySavedModel");
          var diagramData = JSON.parse(textArea.value)

          const request = new XMLHttpRequest();
          request.open('POST', '/'+notebook+'/store_diagram', true);
          request.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
          request.send(JSON.stringify({
                              'filename': "{{filename}}",
                              'diagram': diagramData
          }));

        }
    window.addEventListener('DOMContentLoaded', init);
  </script>


<div id="sample">
  <div id="myDiagramDiv" style="background-color: whitesmoke; border: 1px solid black; width: 100%; height: 1200px; position: relative; -webkit-tap-highlight-color: rgba(255, 255, 255, 0); cursor: auto; font: 10pt helvetica, arial, sans-serif;"><canvas tabindex="0" width="1054" height="398" style="position: absolute; top: 0px; left: 0px; z-index: 2; user-select: none; touch-action: none; width: 1054px; height: 398px; cursor: auto;">This text is displayed if your browser does not support the Canvas HTML element.</canvas><div style="position: absolute; overflow: auto; width: 1054px; height: 398px; z-index: 1;"><div style="position: absolute; width: 1px; height: 1px;"></div></div></div>
  <textarea id="myTransaction" style="width:100%;height:200px"></textarea>
  <button id="SaveButton" onclick="save()">Insert state to textArea</button>
  <button onclick="load()">(Re)load</button>
  <button onclick="store_diagram('{{ notebook }}')">Store diagram</button>
  Diagram Model saved in JSON format:
  <br>

  <!--Area of nodes--> 
  <textarea id="mySavedModel" style="width:100%;height:300px">
      {}
  </textarea>

  </body>
  </html>
